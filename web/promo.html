<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vidéo démo – La Palette</title>
  <style>
    body { margin:0; background:#111; color:#fff; font-family: Montserrat, system-ui, -apple-system, Segoe UI, sans-serif; }
    .wrap { max-width:1100px; margin:0 auto; padding: 0 1rem 2rem; }
    header { position:sticky; top:0; background:#111; padding:0.75rem 0; z-index:2; }
    h1 { font-size:1.2rem; margin:.25rem 0 .5rem; }
    .panel { background:#1c1c1c; border:1px solid #2a2a2a; border-radius:8px; padding:0.75rem; margin-bottom:1rem; }
    .row { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    label { font-size:0.9rem; color:#ddd; }
    input[type="file"], textarea, input[type="text"] { background:#111; color:#eee; border:1px solid #333; border-radius:6px; padding:0.5rem; }
    textarea { width:100%; min-height:70px; resize:vertical; }
    button { background:#e0001a; color:#fff; border:none; border-radius:999px; padding:0.5rem .9rem; font-weight:600; cursor:pointer; }
    button.secondary { background:#343a40; }
    .grid { display:grid; grid-template-columns: 1fr; gap:0.5rem; }
    @media (min-width: 860px){ .grid { grid-template-columns: repeat(2, 1fr); } }

    .stage { position:relative; background:#000; border-radius:8px; overflow:hidden; aspect-ratio:16/9; width:100%; max-width:1000px; margin:0 auto; box-shadow:0 8px 30px rgba(0,0,0,.35); }
    canvas { width:100%; height:100%; display:block; background:#000; }
    .note { font-size:0.85rem; color:#bbb; }
  </style>
</head>
<body>
  <script src="config.js?v=20260115"></script>
  <script defer src="header.js"></script>

  <div class="wrap">
    <header>
      <h1>Générateur de vidéo démo (narration + avatar)</h1>
      <div class="note">Crée une vidéo .webm (Chrome) racontant le parcours: commande client → préparation → livraison → facture. Aucune donnée n'est envoyée à un serveur.</div>
    </header>

    <div class="panel">
      <div class="row">
        <div>
          <label>Avatar (photo visage, optionnel):
            <input type="file" id="avatarInput" accept="image/*" />
          </label>
        </div>
        <div>
          <label>Voix (narration):
            <input type="text" id="voiceLang" value="fr-FR" title="Lang code e.g. fr-FR, en-US" />
          </label>
        </div>
        <div>
          <label><input type="checkbox" id="useIntro" checked /> Inclure intro</label>
          <label style="margin-left:10px;"><input type="checkbox" id="useOutro" checked /> Inclure outro</label>
        </div>
        <div>
          <button id="previewBtn">Aperçu lecture</button>
          <button id="recordBtn">Enregistrer la vidéo</button>
          <button id="stopBtn" class="secondary">Stop</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="grid" id="scenesGrid"></div>
      <div class="note">Vous pouvez modifier les textes avant l'enregistrement. Images chargées depuis web/image/</div>
    </div>

    <div class="stage"><canvas id="stage" width="1920" height="1080"></canvas></div>
  </div>

  <script>
    (function(){
      // Default scenes using existing repo images
      var scenes = [
        { img: 'image/client2.png', text: "La cliente explore la boutique La Palette, ajoute des produits et passe sa commande.", durationSec: 3.5, zoom: true, highlight: null },
        { img: 'image/all1.png', text: "L'utilisatrice se connecte à son compte et retrouve immédiatement ses commandes.", durationSec: 3.2, zoom: true, highlight: null },
        { img: 'image/shop2.png', text: "Côté magasin, l'équipe visualise la commande dans la liste et prépare les articles.", durationSec: 3.8, zoom: true, highlight: null },
        { img: 'image/shop3.png', text: "La préparation est finalisée; le statut passe à ‘prêt pour livraison’.", durationSec: 3.2, zoom: true, highlight: null },
        { img: 'image/liver2.png', text: "Le livreur récupère la commande prête et consulte sa tournée.", durationSec: 3.2, zoom: true, highlight: null },
        { img: 'image/liver1.png', text: "Lors de la remise, le QR est scanné et la commande passe au statut ‘Terminée’.", durationSec: 3.2, zoom: true, highlight: null },
        { img: 'image/all3.png', text: "La cliente accède à son profil, consulte sa facture et peut l'enregistrer ou l'imprimer.", durationSec: 3.2, zoom: false, highlight: null }
      ];
      // keep a reference to default repo images for easy reset
      scenes.forEach(function(s){ s.defaultImg = s.img; });

      // Build editable form
      var grid = document.getElementById('scenesGrid');
      function buildSceneEditors(){
        grid.innerHTML = '';
        scenes.forEach(function(s, idx){
          var wrap = document.createElement('div');
          wrap.className = 'panel';
          var labelText = (s.img && typeof s.img === 'string' && s.img.indexOf('data:') === 0)
            ? ((s.imgName||'fichier local') + ' (local)')
            : (s.img||'');
          wrap.innerHTML = '<label>Image scène ' + (idx+1) + ' <small>(' + labelText + ')</small></label>' +
            '<div class="row">'+
              '<input type="text" '+ (s.img && s.img.indexOf('data:')===0 ? 'placeholder="fichier local sélectionné" value=""' : 'value="'+ s.img +'"') +' data-idx="'+idx+'" class="imgPath" style="flex:1;min-width:260px"/>'+
              '<input type="file" accept="image/*" class="imgFile" data-idx="'+idx+'" />'+
              '<button type="button" class="resetImgBtn" data-idx="'+idx+'">Réinitialiser</button>'+
            '</div>'+
            '<label>Texte voix-off</label>'+
            '<textarea class="sceneText" data-idx="'+idx+'">'+ s.text +'</textarea>'+
            '<div class="row">'+
              '<label>Durée (sec) <input type="number" step="0.1" min="1" value="'+ (s.durationSec||3.2) +'" class="durationInput" data-idx="'+idx+'" style="width:90px"/></label>'+
              '<label><input type="checkbox" class="zoomChk" data-idx="'+idx+'" '+ (s.zoom?'checked':'') +'/> Zoom léger</label>'+
              '<label>Highlight (x,y,w,h) <input type="text" placeholder="ex: 800,220,260,90" class="hlInput" data-idx="'+idx+'" style="width:180px" value="'+ (s.highlight? [s.highlight.x,s.highlight.y,s.highlight.w,s.highlight.h].join(',') : '') +'"/></label>'+
              '<button type="button" class="setHlBtn" data-idx="'+idx+'">Dessiner highlight sur la vidéo</button>'+
            '</div>';
          grid.appendChild(wrap);
        });
      }
      buildSceneEditors();

      // Click-to-highlight support (declare in outer scope so drawScene can access)
      var drawHLIndex = -1; var dragStart = null; var dragCurrent = null;
      // Register the click handler once
      grid.addEventListener('click', function(e){
        if (e.target.classList.contains('setHlBtn')){
          drawHLIndex = +e.target.getAttribute('data-idx');
          dragStart = null; dragCurrent = null;
          alert('Mode highlight actif pour la scène '+(drawHLIndex+1)+'. Cliquez-glissez sur la vidéo pour tracer un rectangle.');
        }
      });

      // Update handlers
      grid.addEventListener('input', function(e){
        if (e.target.classList.contains('imgPath')){
          var i = +e.target.getAttribute('data-idx');
          var val = (e.target.value||'').trim();
          if (val){ scenes[i].img = val; scenes[i].imgName = null; }
        }
        if (e.target.classList.contains('sceneText')){
          var i2 = +e.target.getAttribute('data-idx');
          scenes[i2].text = e.target.value;
        }
        if (e.target.classList.contains('durationInput')){
          var i3 = +e.target.getAttribute('data-idx');
          scenes[i3].durationSec = Math.max(1, parseFloat(e.target.value)||3.2);
        }
        if (e.target.classList.contains('zoomChk')){
          var i4 = +e.target.getAttribute('data-idx');
          scenes[i4].zoom = !!e.target.checked;
        }
        if (e.target.classList.contains('hlInput')){
          var i5 = +e.target.getAttribute('data-idx');
          var parts = (e.target.value||'').split(',').map(function(v){ return parseFloat(v); });
          if (parts.length===4 && parts.every(function(n){ return !isNaN(n); })){
            scenes[i5].highlight = { x:parts[0], y:parts[1], w:parts[2], h:parts[3] };
          } else { scenes[i5].highlight = null; }
        }
      });

      // Handle image selection via OS file picker per scene
      grid.addEventListener('change', function(e){
        if (e.target.classList.contains('imgFile')){
          var idx = +e.target.getAttribute('data-idx');
          var file = e.target.files && e.target.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function(){
            scenes[idx].img = reader.result; // data URL avoids CORS
            scenes[idx].imgName = file.name;
            // re-render labels
            buildSceneEditors();
          };
          reader.readAsDataURL(file);
        }
      });

      // Handle reset to default repo image
      grid.addEventListener('click', function(e){
        if (e.target.classList.contains('resetImgBtn')){
          var idx = +e.target.getAttribute('data-idx');
          if (scenes[idx] && scenes[idx].defaultImg){
            scenes[idx].img = scenes[idx].defaultImg;
            scenes[idx].imgName = null;
            buildSceneEditors();
          }
        }
      });

      // Canvas renderer
      var canvas = document.getElementById('stage');
      var ctx = canvas.getContext('2d');

      function loadImage(src){
        return new Promise(function(resolve){
          var img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = function(){ resolve(img); };
          img.onerror = function(){ resolve(null); };
          // For data URLs or empty sources, assign directly.
          if (!src || (typeof src === 'string' && src.indexOf('data:') === 0)){
            img.src = src || '';
            return;
          }
          // cache-bust to ensure latest asset when user replaces files on disk
          try {
            var hasQuery = (src||'').indexOf('?') !== -1;
            img.src = src + (hasQuery ? '&' : '?') + 'v=' + Date.now();
          } catch(e){ img.src = src; }
        });
      }

      function drawRoundImage(img, x, y, r){
        if (!img) return;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x + r, y + r, r, 0, Math.PI*2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(img, x, y, r*2, r*2);
        ctx.restore();
        ctx.strokeStyle = 'rgba(255,255,255,0.85)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(x + r, y + r, r, 0, Math.PI*2);
        ctx.stroke();
      }

      function wrapText(text, x, y, maxWidth, lineHeight){
        var words = (text||'').split(' ');
        var line = '';
        for (var n=0; n<words.length; n++){
          var testLine = line + words[n] + ' ';
          var metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && n>0){
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, y);
      }

      function wrapLines(text, maxWidth){
        var words = (text||'').split(' ');
        var line = '';
        var lines = [];
        for (var n=0; n<words.length; n++){
          var testLine = line + words[n] + ' ';
          var metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && n>0){
            lines.push(line.trimEnd());
            line = words[n] + ' ';
          } else {
            line = testLine;
          }
        }
        if (line) lines.push(line.trimEnd());
        return lines;
      }

      function drawRoundRect(x, y, w, h, r){
        var rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      function drawScene(bgImg, avatarImg, text, progress, scene){
        var cw = canvas.width, ch = canvas.height;
        // base fill
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,cw,ch);
        if (bgImg){
          // blurred backdrop (letterbox)
          ctx.save();
          ctx.filter = 'blur(16px) brightness(0.8)';
          var sb = Math.max(cw/bgImg.width, ch/bgImg.height);
          ctx.drawImage(bgImg, (cw - bgImg.width*sb)/2, (ch - bgImg.height*sb)/2, bgImg.width*sb, bgImg.height*sb);
          ctx.restore();
          // foreground contain (no crop) + gentle zoom
          var sContain = Math.min(cw/bgImg.width, ch/bgImg.height);
          var zoom = (scene && scene.zoom) ? 1 + 0.03*progress : 1; // slightly softer zoom
          // avoid upscaling beyond native to keep sharpness
          var base = Math.min(1, sContain);
          var s = Math.min(1, base * zoom);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          var w = bgImg.width*s, h = bgImg.height*s;
          var dx = (cw - w)/2, dy = (ch - h)/2;
          ctx.drawImage(bgImg, dx, dy, w, h);
        } else if (scene && scene.twoTone){
          // two-tone brand background
          ctx.fillStyle = '#F6F0E6';
          ctx.fillRect(0,0,cw, Math.floor(ch*0.55));
          ctx.fillStyle = '#EDDDCB';
          ctx.fillRect(0, Math.floor(ch*0.55), cw, ch);
          // title/subtitle
          ctx.fillStyle = '#111';
          ctx.font = 'bold 56px Montserrat, sans-serif';
          ctx.fillText(scene.title||'', 80, 200);
          ctx.fillStyle = '#333';
          ctx.font = '28px Montserrat, sans-serif';
          if (scene.subtitle && !(scene.noSubtitle)) wrapText(scene.subtitle, 80, 250, cw-160, 38);
          // optional body text rendered on the two-tone screen (for intro/outro)
          if (scene.bodyText){
            ctx.fillStyle = '#222';
            ctx.font = '24px Montserrat, sans-serif';
            wrapText(scene.bodyText, 80, 320, cw-160, 34);
          }
          // optional pricing table (simple 4-column grid)
          if (scene.table && Array.isArray(scene.table.headers) && Array.isArray(scene.table.rows)){
            var tableTop = 420;
            var colCount = scene.table.headers.length;
            var tableLeft = 80;
            var tableWidth = cw - 160;
            var colW = tableWidth / Math.max(1,colCount);
            // header row
            for (var c=0;c<colCount;c++){
              var x = tableLeft + c*colW;
              ctx.fillStyle = '#ffffff';
              ctx.globalAlpha = 0.9;
              ctx.fillRect(x, tableTop, colW-12, 44);
              ctx.globalAlpha = 1;
              ctx.fillStyle = '#111';
              ctx.font = 'bold 22px Montserrat, sans-serif';
              ctx.fillText(String(scene.table.headers[c]||''), x+12, tableTop+30);
            }
            // rows
            var rowH = 40;
            for (var r=0;r<scene.table.rows.length;r++){
              var y = tableTop + 44 + r*rowH;
              for (var c2=0;c2<colCount;c2++){
                var x2 = tableLeft + c2*colW;
                // cell background alternating
                ctx.fillStyle = (r%2===0) ? 'rgba(255,255,255,0.75)' : 'rgba(255,255,255,0.6)';
                ctx.fillRect(x2, y, colW-12, rowH-4);
                ctx.fillStyle = '#111';
                ctx.font = '20px Montserrat, sans-serif';
                var cell = (scene.table.rows[r] && scene.table.rows[r][c2]) ? String(scene.table.rows[r][c2]) : '';
                ctx.fillText(cell, x2+12, y+26);
              }
            }
          }
          // logo optional
          // omitted to avoid cross-origin issues from external hosts; images from same site are fine if needed later
        }
        // highlight box (optional)
        if (scene && scene.highlight){
          ctx.save();
          ctx.strokeStyle = 'rgba(224,0,26,0.9)';
          ctx.lineWidth = 5;
          var pulse = 0.6 + 0.4*Math.sin(progress*2*Math.PI);
          ctx.globalAlpha = pulse;
          ctx.strokeRect(scene.highlight.x, scene.highlight.y, scene.highlight.w, scene.highlight.h);
          ctx.restore();
        }
        // live drawing rectangle
        if (drawHLIndex>=0 && scenes[drawHLIndex]===scene && dragStart && dragCurrent){
          ctx.save();
          ctx.strokeStyle = 'rgba(224,0,26,0.8)';
          ctx.setLineDash([10,6]);
          ctx.lineWidth = 3;
          var rx = Math.min(dragStart.x, dragCurrent.x), ry = Math.min(dragStart.y, dragCurrent.y);
          var rw = Math.abs(dragCurrent.x - dragStart.x), rh = Math.abs(dragCurrent.y - dragStart.y);
          ctx.strokeRect(rx, ry, rw, rh);
          ctx.restore();
        }
        // caption box (dynamic, high-contrast) unless disabled
        if (!(scene && scene.noCaption)){
          var padX = 24, padY = 18;
          ctx.font = '26px Montserrat, sans-serif';
          var maxTextW = Math.min(1200, cw - 80 - 2*padX - 160);
          var lines = wrapLines(text||'', maxTextW);
          var lineH = 34;
          var textH = Math.max(lineH, lines.length * lineH);
          // compute widest line
          var widest = 0; for (var li=0; li<lines.length; li++){ widest = Math.max(widest, ctx.measureText(lines[li]).width); }
          var boxW = widest + 2*padX;
          var boxH = textH + 2*padY;
          var boxX = 40; var boxY = ch - (boxH + 40);
          // fade in/out for readability over time
          var fade = 1;
          if (typeof progress === 'number'){
            var fin = Math.min(1, progress*3);
            var fout = Math.min(1, (1-progress)*3);
            fade = Math.min(fin, fout);
          }
          // background with rounded corners and subtle gradient
          ctx.save();
          ctx.globalAlpha = 0.85 * fade;
          var grad = ctx.createLinearGradient(boxX, boxY, boxX, boxY+boxH);
          grad.addColorStop(0, 'rgba(0,0,0,0.75)');
          grad.addColorStop(1, 'rgba(0,0,0,0.55)');
          ctx.fillStyle = grad;
          drawRoundRect(boxX, boxY, boxW, boxH, 16);
          ctx.fill();
          ctx.restore();
          // text with slight stroke and shadow for clarity
          ctx.save();
          ctx.globalAlpha = fade;
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = 'rgba(0,0,0,0.75)';
          ctx.lineWidth = 3;
          ctx.shadowColor = 'rgba(0,0,0,0.4)';
          ctx.shadowBlur = 6;
          for (var li2=0; li2<lines.length; li2++){
            var ty = boxY + padY + 8 + li2*lineH;
            var tx = boxX + padX;
            ctx.strokeText(lines[li2], tx, ty);
            ctx.fillText(lines[li2], tx, ty);
          }
          ctx.restore();
        }
        // avatar with subtle bob
        if (avatarImg){
          var bob = Math.sin(progress*2*Math.PI) * 4; // 4px bob
          drawRoundImage(avatarImg, cw - 40 - 120, ch - (boxH + 40) + 10 + bob, 60);
        }
      }

      // Speech synthesis: pick a natural/professional voice when available
      var _voices = [];
      function refreshVoices(){
        try { _voices = window.speechSynthesis ? window.speechSynthesis.getVoices() || [] : []; } catch(e){ _voices = []; }
      }
      if (window.speechSynthesis){
        refreshVoices();
        window.speechSynthesis.onvoiceschanged = refreshVoices;
      }
      function pickBestVoice(lang){
        if (!_voices || !_voices.length) return null;
        var cand = _voices.filter(function(v){ return v.lang && v.lang.toLowerCase().indexOf((lang||'fr-FR').toLowerCase())===0; });
        // Prefer Google/Enhanced voices if available
        var pref = cand.find(function(v){ return /google|enhanced|natural/i.test(v.name||''); }) || cand[0];
        return pref || null;
      }
      function speak(text, lang){
        return new Promise(function(resolve){
          if (!window.speechSynthesis){ return resolve(); }
          var u = new SpeechSynthesisUtterance(text||'');
          u.lang = lang || 'fr-FR';
          var v = pickBestVoice(u.lang);
          if (v) u.voice = v;
          u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
          u.onend = function(){ resolve(); };
          u.onerror = function(){ resolve(); };
          try { window.speechSynthesis.speak(u); } catch(e){ resolve(); }
        });
      }

      // Playback controller
      var avatarImgEl = null;
      document.getElementById('avatarInput').addEventListener('change', function(e){
        var f = e.target.files && e.target.files[0];
        if (!f) { avatarImgEl = null; return; }
        var reader = new FileReader();
        reader.onload = function(){
          var img = new Image();
          img.onload = function(){ avatarImgEl = img; };
          img.src = reader.result;
        };
        reader.readAsDataURL(f);
      });

      var playing = false;
      async function playScenes(recording){
        if (playing) return; playing = true;
        var lang = (document.getElementById('voiceLang').value||'fr-FR').trim();
        var fps = 30;
        // Build sequence with optional intro/outro
        var seq = [];
        var useIntro = document.getElementById('useIntro') && document.getElementById('useIntro').checked;
        var useOutro = document.getElementById('useOutro') && document.getElementById('useOutro').checked;
        if (useIntro){
          seq.push({ twoTone:true, img:null, title:'Shop Chain', subtitle:"Application e‑commerce & supply chain en ligne. Améliore l'expérience client et apporte une visibilité claire du flux de vente.", text:"Bienvenue sur Shop Chain. Une application en ligne qui fluidifie la commande, la préparation et la livraison, avec un suivi clair pour les équipes et une expérience client plus sereine.", bodyText:"Bienvenue sur Shop Chain. Une application en ligne qui fluidifie la commande, la préparation et la livraison, avec un suivi clair pour les équipes et une expérience client plus sereine.", durationSec: 4.5, zoom:false, noCaption:true });
        }
        // main scenes
        seq = seq.concat(scenes);
        if (useOutro){
          seq.push({ twoTone:true, img:null, title:'Merci', subtitle:"Présenté par Lai Wah TSE – Cœur du ciel • https://kyoceratest.github.io/cdcwebsite/", text:"Nos services: Digital Marketing, Branding & Design, Strategy & Consulting.", bodyText:"Nos services: Digital Marketing, Branding & Design, Strategy & Consulting.", durationSec: 6.0, zoom:false, noVoice:true, noSubtitle:true, noCaption:true, table:{ headers:['MVP','Business','Pro','Maintenance'], rows:[ ['2\u202f500–4\u202f500 €','5\u202f000–9\u202f000 €','10\u202f000–18\u202f000 €','400–600 €/mois'] ] } });
        }
        for (var i=0;i<seq.length;i++){
          var s = seq[i];
          var bg = await loadImage(s.img);
          // start narration concurrently unless disabled; never let it block progression
          var speakPromise = (s.noVoice || !s.text) ? Promise.resolve() : speak(s.text, lang);
          var frames = Math.max(1, Math.round((s.durationSec||3.2) * fps));
          for (var t=0;t<frames;t++){
            var progress = frames>1 ? (t/(frames-1)) : 1;
            drawScene(bg, avatarImgEl, s.text, progress, s);
            if (recording) await new Promise(r=>setTimeout(r, 1000/fps)); else await new Promise(r=>requestAnimationFrame(r));
          }
          // allow narration some time (if any), but don't hang if speech synthesis never ends
          var safeWait = (s.noVoice || !s.text) ? 0 : Math.max(800, Math.round((s.durationSec||3.2)*1000));
          await Promise.race([speakPromise, new Promise(function(r){ setTimeout(r, safeWait); })]);
          if (!playing) break;
        }
        playing = false;
      }

      document.getElementById('previewBtn').addEventListener('click', function(){ playScenes(false); });

      // Recording using MediaRecorder from canvas stream
      var mediaRecorder = null, recorded = [];
      async function startRecording(){
        if (mediaRecorder && mediaRecorder.state === 'recording') return;
        recorded = [];
        var stream = canvas.captureStream(30);
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
        mediaRecorder.ondataavailable = function(e){ if (e.data && e.data.size) recorded.push(e.data); };
        mediaRecorder.onstop = function(){
          var blob = new Blob(recorded, { type: 'video/webm' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.href = url; a.download = 'LaPalette_Demo.webm'; a.click();
          URL.revokeObjectURL(url);
        };
        mediaRecorder.start();
        await playScenes(true);
        if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
      }

      document.getElementById('recordBtn').addEventListener('click', startRecording);
      document.getElementById('stopBtn').addEventListener('click', function(){
        playing = false;
        if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
      });

      // Canvas drag handlers for highlight
      canvas.addEventListener('mousedown', function(e){
        if (drawHLIndex<0) return;
        var rect = canvas.getBoundingClientRect();
        dragStart = { x: (e.clientX - rect.left) * (canvas.width/rect.width), y: (e.clientY - rect.top) * (canvas.height/rect.height) };
        dragCurrent = { x: dragStart.x, y: dragStart.y };
      });
      canvas.addEventListener('mousemove', function(e){
        if (drawHLIndex<0 || !dragStart) return;
        var rect = canvas.getBoundingClientRect();
        dragCurrent = { x: (e.clientX - rect.left) * (canvas.width/rect.width), y: (e.clientY - rect.top) * (canvas.height/rect.height) };
      });
      canvas.addEventListener('mouseup', function(e){
        if (drawHLIndex<0 || !dragStart) return;
        var rx = Math.min(dragStart.x, dragCurrent.x), ry = Math.min(dragStart.y, dragCurrent.y);
        var rw = Math.abs(dragCurrent.x - dragStart.x), rh = Math.abs(dragCurrent.y - dragStart.y);
        scenes[drawHLIndex].highlight = { x: Math.round(rx), y: Math.round(ry), w: Math.round(rw), h: Math.round(rh) };
        // Reflect in editor field
        buildSceneEditors();
        drawHLIndex = -1; dragStart = null; dragCurrent = null;
      });
    })();
  </script>
</body>
</html>
